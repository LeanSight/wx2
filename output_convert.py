"""
Tool for converting transcriptions generated by transcribe.py to different formats.
Maintains the same architecture and reuses existing code.
"""
from __future__ import annotations
import sys
import argparse
from pathlib import Path
from typing import Optional, Union, List

# Local imports
from formatters import OutputFormat, convert_output, output_format_type, create_speaker_map
from helpers import log_time, logger, format_path

@log_time
def parse_arguments():
    """
    Parses command line arguments for the conversion tool.
    
    Returns:
        argparse.Namespace: Parsed arguments
    """
    parser = argparse.ArgumentParser(
        description="Tool for converting transcriptions to different formats.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Usage examples:
  # Convert to SRT format
  convert.py transcription.json -f srt

  # Convert to VTT with custom speaker names
  convert.py transcription.json -f vtt --speaker-names="John,Mary,Peter"

  # Convert to plain text and save in specific directory
  convert.py transcription.json -f txt -o /output/path/

  # By default, converted files are saved in the same folder as the original JSON file
  convert.py /original/path/transcription.json -f srt
        """
    )
    
    # Main arguments
    parser.add_argument(
        "input_file", 
        type=str, 
        help="Path to the JSON transcription file generated by transcribe.py"
    )
    
    parser.add_argument(
        "-f", "--format",
        dest="output_format",
        type=str,
        choices=["json", "srt", "vtt", "txt"],
        required=True,
        help="Desired output format"
    )
    
    parser.add_argument(
        "-o", "--output",
        dest="output_dir",
        type=str,
        help="Directory to save the result (default: same folder as the original JSON file)"
    )
    
    parser.add_argument(
        "--output-name",
        dest="output_name",
        type=str,
        help="Output filename (without extension, default: same name as input file)"
    )
    
    parser.add_argument(
        "--speaker-names",
        type=str,
        help="Comma-separated list of names to replace speaker labels (e.g.: \"John,Mary,Peter\")"
    )
    
    args = parser.parse_args()
    
    # Validate that the input file exists and is JSON
    input_path = Path(args.input_file)
    if not input_path.exists():
        parser.error(f"Input file does not exist: {args.input_file}")
    
    if input_path.suffix.lower() != ".json":
        parser.error(f"Input file must be JSON: {args.input_file}")
    
    return args

@log_time
def convert_transcript(
    input_file: Union[str, Path],
    output_format: str,
    output_dir: Optional[Union[str, Path]] = None,
    output_name: Optional[str] = None,
    speaker_names: Optional[str] = None
) -> Path:
    """
    Converts a JSON transcription file to the specified format.
    
    Args:
        input_file: Path to the input JSON file
        output_format: Desired output format (json, srt, vtt, txt)
        output_dir: Directory to save the output file (optional)
        output_name: Output filename without extension (optional)
        speaker_names: Comma-separated list of speaker names (optional)
    
    Returns:
        Path: Path to the generated output file
    """
    # Convert input_file to Path
    input_path = Path(input_file)
    
    # Determine output directory
    if output_dir is None:
        # Default: save in the same folder as the original JSON file
        output_dir = input_path.parent
        logger.info(f"Using default output directory: {format_path(str(output_dir))}")
    else:
        output_dir = Path(output_dir)
        if not output_dir.exists():
            logger.info(f"Creating output directory: {format_path(str(output_dir))}")
            output_dir.mkdir(parents=True, exist_ok=True)
    
    # Determine output filename
    if output_name is None:
        output_stem = input_path.stem
    else:
        output_stem = output_name
    
    # Complete path of the output file
    output_path = output_dir / f"{output_stem}.{output_format}"
    
    # Convert to the requested format
    try:
        format_enum = OutputFormat(output_format)
        result_path = convert_output(
            input_path=input_path,
            output_format=format_enum,
            output_dir=output_dir,
            speaker_names=speaker_names
        )
        
        # If a custom name was specified and the result has a different name
        if output_name is not None and result_path.stem != output_stem:
            # Rename the file
            new_path = output_dir / f"{output_stem}.{output_format}"
            result_path.rename(new_path)
            result_path = new_path
            logger.info(f"File renamed to: {format_path(str(result_path))}")
        
        return result_path
    
    except Exception as e:
        logger.error(f"[red]Error converting format[/]: {str(e)}")
        raise

@log_time
def main():
    """
    Main function that coordinates the conversion process.
    """
    try:
        # 1. Process arguments
        args = parse_arguments()
        
        # 2. Convert to the requested format
        output_path = convert_transcript(
            input_file=args.input_file,
            output_format=args.output_format,
            output_dir=args.output_dir,
            output_name=args.output_name,
            speaker_names=args.speaker_names
        )
        
        logger.info(f"[green]Conversion completed![/] File saved to: {format_path(str(output_path))}")
        return 0
    
    except Exception as e:
        logger.error(f"[red]Error during execution:[/] {str(e)}")
        logger.debug("Error details:", exc_info=True)
        return 1

if __name__ == "__main__":
    sys.exit(main())